println("Hello world")
:help
object HelloWorld {
def main(args:Array[String]) {
println("Hello, world!")
}
HelloWorld.main("1")
HelloWorld.main(["1"])
HelloWorld.main({"1"})
HelloWorld.main(null)
val numbers = Array(1,2,3)
numbers
HelloWorld.main(numbers)
val numbers = Array("1","2","3")
HelloWorld.main(numbers)
print 'hi there'
write('hi there')
print('hi there')
println('hi there')
println("hi there")
println "hellop"
println "hellop";
case class Foo1(a:String)
f1 = Foo1(2)
Foo1 f1 = Foo1(2)
f = new Foo1(1)
Foo1 f;
Foo1
val f = Foo1(12)
val f = Foo1("hi")
f.a
case class Foo2(b: Integer)
val f2 = Foo2(12)
f2.b
abstract class Foo
case class Foo1(name: String) extends Foo
case class Foo2(age: Integer) extends Foo
def test(val: Foo) : String = val match {
def test(f: Foo) : String = f match {
case Foo1(name) => "my name is " + name
case Foo2(age) => "my age is " + age
}
val j = Foo1("John")
val c = Foo2(42)
test(j)
test(c)
test("12")
def type(o: Object): String => o match {
def typeof(o: Object): String => o match {
def typeof(o: Object): String = o match {
 Integer(n) => "The number is " + n
def typeof(o: Object): String = o match {
 case Integer(n) => "The number is " + n
 case String(s) => "The sring is " + s
}
def test : String => String
def test : String => String {
 return "hi"
def double(s : String) {
  return s + s
}
def double(s : String): String {
 return s + s
def double(s : String): String = {
 return s + s
}
double('hi')
double("hi")
def doublef(f : (String) => String): String = {
 return f('test')
def doublef(s: String, f : (String) => String): String = {
 return f(s)
}
doublef("hi", doublef)
doublef
doublef()
double("hi")
doublef("hi", double)
def doublef(s: String, f : (String) => String): String = {
 return f(s) + f(s)
}
doublef("hi", double)
def test(): String {
 return "hi"
def test(): String {
 "hi"
def test(s: String): String {
 print(s)
help
?
=:=
printf "hi"
var a = [1,2,3]
var z = Array(1,2,3)
z
filter
z.filter
def isTwo(v: Integer): Boolean = {
 return v == 2
}
isTwo(2)
isTwo(3)
z
z.filter(isTwo)
def isTwo(v: Int): Boolean = {
 return v == 2
}
z.filter(isTwo)
z.filter(2 ==)
z.filter(3 >)
(3).>
(3).>(2)
z.map
z.map(2*)
z
var z = new Array(1,2,3)
var z = Array(1,2,3)
z
z.reduce
z.reduce(+)
z.reduce((Int a, Int b)=>Int = { a + b })
z.reduce((a:Int,b:Int) => a + b)
+
.
+(1,2)
add
z.reduce((a:Int,b:Int) => a * b)
z.reduce((a:Int,b:Int) => a / b)
z.reduce((a:Int,b:Int) => a ** b)
z.reduce((a:Int,b:Int) => a * b)
:help
var s = :sh ls
:sh ls
:type 3
def a = 5
a
var b = 3
b
val c = 7
c
a
b
c
c = 12
b = 12
b
a = 3
var counter = 0
def count() : Int = {
 counter += 1
 return counter
}
count()
def c1 = count()
val c2 = count()
var c3 = count()
c1
count()
def you(s: String) = s + " you"
you("rascal")
def sum(a:Int, b: => Int) = a + b
def mul(a:
d
;
def mul(a:Int,b:=>Int) = a * b
def mul(a:Int,b: => Int) = a * b
mul(2,3)
mul(2,3+1)
mul(3+1,2)
mul(sum(3,1),2)
mul(2,sum(3,1))
!fals
!false
if 1 > 2 'hello'
if 1 > 2 "hello"
if (1 > 2) "hello"
if (1 > 2) "hello" else "goodbye"
1 +
1
1+2
1+
(1).
+(2)
def test(f:()=>String):String = {
 f()
}
test(()=>"hello")
def test = (s:String) => s
test('hi')
test
test("hi")
def dbl = (i:Int) => i*2
dbl(2)
dbl(dbl(2))
